{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "f1d6be2d",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2025-10-19T07:37:50.969215Z",
     "iopub.status.busy": "2025-10-19T07:37:50.968738Z",
     "iopub.status.idle": "2025-10-19T07:38:15.143769Z",
     "shell.execute_reply": "2025-10-19T07:38:15.142929Z"
    },
    "papermill": {
     "duration": 24.181886,
     "end_time": "2025-10-19T07:38:15.145325",
     "exception": false,
     "start_time": "2025-10-19T07:37:50.963439",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import nltk.data\n",
    "import logging\n",
    "import csv\n",
    "from gensim.models import Word2Vec\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "\n",
    "from bs4 import MarkupResemblesLocatorWarning\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\", category=MarkupResemblesLocatorWarning)\n",
    "\n",
    "import sys\n",
    "sys.path.append('/kaggle/input/kaggleword2vecutility/')\n",
    "from KaggleWord2VecUtility import KaggleWord2VecUtility\n",
    "\n",
    "\n",
    "def makeFeatureVec(words, model, num_features):\n",
    "    featureVec = np.zeros((num_features,), dtype=\"float32\")\n",
    "    nwords = 0\n",
    "    index2word_set = set(model.wv.key_to_index)\n",
    "    for word in words:\n",
    "        if word in index2word_set:\n",
    "            nwords += 1\n",
    "            featureVec = np.add(featureVec, model.wv[word])\n",
    "    if nwords > 0:\n",
    "        featureVec = np.divide(featureVec, nwords)\n",
    "    return featureVec\n",
    "\n",
    "\n",
    "def getAvgFeatureVecs(reviews, model, num_features):\n",
    "    reviewFeatureVecs = np.zeros((len(reviews), num_features), dtype=\"float32\")\n",
    "    for counter, review in enumerate(reviews):\n",
    "        if counter % 1000 == 0:\n",
    "            print(\"Review {} of {}\".format(counter, len(reviews)))\n",
    "        reviewFeatureVecs[counter] = makeFeatureVec(review, model, num_features)\n",
    "    return reviewFeatureVecs\n",
    "\n",
    "\n",
    "def getCleanReviews(reviews):\n",
    "    clean_reviews = []\n",
    "    for review in reviews[\"review\"]:\n",
    "        clean_reviews.append(KaggleWord2VecUtility.review_to_wordlist(review, remove_stopwords=True))\n",
    "    return clean_reviews"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "d1435cc7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-10-19T07:38:15.149736Z",
     "iopub.status.busy": "2025-10-19T07:38:15.149311Z",
     "iopub.status.idle": "2025-10-19T07:44:28.680922Z",
     "shell.execute_reply": "2025-10-19T07:44:28.680125Z"
    },
    "papermill": {
     "duration": 373.537428,
     "end_time": "2025-10-19T07:44:28.684686",
     "exception": false,
     "start_time": "2025-10-19T07:38:15.147258",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Read 25000 labeled train reviews, 25000 labeled test reviews, and 50000 unlabeled reviews\n",
      "\n",
      "Parsing sentences from training set\n",
      "Parsing sentences from unlabeled set\n",
      "Training Word2Vec model...\n",
      "kitchen\n",
      "berlin\n",
      "paris\n",
      "[('woman', 0.5991779565811157), ('lady', 0.5987515449523926), ('lad', 0.5809475183486938), ('monk', 0.526863157749176), ('farmer', 0.5262501239776611), ('guy', 0.5126436948776245), ('businessman', 0.509974479675293), ('men', 0.5066616535186768), ('boy', 0.494666188955307), ('person', 0.48965826630592346)]\n",
      "[('princess', 0.705570638179779), ('bride', 0.593708872795105), ('goddess', 0.5814536809921265), ('belle', 0.5792298913002014), ('regina', 0.5789541006088257), ('victoria', 0.5719972848892212), ('eva', 0.5710124969482422), ('nina', 0.5708185434341431), ('starlet', 0.5682228207588196), ('stepmother', 0.5669922232627869)]\n",
      "[('terrible', 0.7658382654190063), ('horrible', 0.7208777666091919), ('abysmal', 0.7154224514961243), ('atrocious', 0.7088383436203003), ('dreadful', 0.6962801814079285), ('horrid', 0.6682615876197815), ('appalling', 0.6590140461921692), ('horrendous', 0.6585850715637207), ('lousy', 0.6323138475418091), ('amateurish', 0.6217606663703918)]\n",
      "Creating average feature vecs for training reviews\n",
      "Review 0 of 25000\n",
      "Review 1000 of 25000\n",
      "Review 2000 of 25000\n",
      "Review 3000 of 25000\n",
      "Review 4000 of 25000\n",
      "Review 5000 of 25000\n",
      "Review 6000 of 25000\n",
      "Review 7000 of 25000\n",
      "Review 8000 of 25000\n",
      "Review 9000 of 25000\n",
      "Review 10000 of 25000\n",
      "Review 11000 of 25000\n",
      "Review 12000 of 25000\n",
      "Review 13000 of 25000\n",
      "Review 14000 of 25000\n",
      "Review 15000 of 25000\n",
      "Review 16000 of 25000\n",
      "Review 17000 of 25000\n",
      "Review 18000 of 25000\n",
      "Review 19000 of 25000\n",
      "Review 20000 of 25000\n",
      "Review 21000 of 25000\n",
      "Review 22000 of 25000\n",
      "Review 23000 of 25000\n",
      "Review 24000 of 25000\n",
      "Creating average feature vecs for test reviews\n",
      "Review 0 of 25000\n",
      "Review 1000 of 25000\n",
      "Review 2000 of 25000\n",
      "Review 3000 of 25000\n",
      "Review 4000 of 25000\n",
      "Review 5000 of 25000\n",
      "Review 6000 of 25000\n",
      "Review 7000 of 25000\n",
      "Review 8000 of 25000\n",
      "Review 9000 of 25000\n",
      "Review 10000 of 25000\n",
      "Review 11000 of 25000\n",
      "Review 12000 of 25000\n",
      "Review 13000 of 25000\n",
      "Review 14000 of 25000\n",
      "Review 15000 of 25000\n",
      "Review 16000 of 25000\n",
      "Review 17000 of 25000\n",
      "Review 18000 of 25000\n",
      "Review 19000 of 25000\n",
      "Review 20000 of 25000\n",
      "Review 21000 of 25000\n",
      "Review 22000 of 25000\n",
      "Review 23000 of 25000\n",
      "Review 24000 of 25000\n",
      "Fitting a random forest to labeled training data...\n",
      "Wrote /kaggle/working/Word2Vec_AverageVectors.csv\n"
     ]
    }
   ],
   "source": [
    "if __name__ == '__main__':\n",
    "    train_path = '/kaggle/input/word2vec-nlp-tutorial/labeledTrainData.tsv/labeledTrainData.tsv'\n",
    "    test_path = '/kaggle/input/word2vec-nlp-tutorial/testData.tsv/testData.tsv'\n",
    "    unlabeled_path = '/kaggle/input/word2vec-nlp-tutorial/unlabeledTrainData.tsv/unlabeledTrainData.tsv'\n",
    "\n",
    "    # 读取数据\n",
    "    train = pd.read_csv(train_path, header=0, delimiter=\"\\t\", quoting=csv.QUOTE_NONE)\n",
    "    test = pd.read_csv(test_path, header=0, delimiter=\"\\t\", quoting=csv.QUOTE_NONE)\n",
    "    unlabeled_train = pd.read_csv(unlabeled_path, header=0, delimiter=\"\\t\", quoting=csv.QUOTE_NONE)\n",
    "\n",
    "    print(\"Read {} labeled train reviews, {} labeled test reviews, and {} unlabeled reviews\\n\".format(\n",
    "        train[\"review\"].size, test[\"review\"].size, unlabeled_train[\"review\"].size))\n",
    "\n",
    "    tokenizer = nltk.data.load('tokenizers/punkt/english.pickle')\n",
    "\n",
    "    # 解析句子\n",
    "    sentences = []\n",
    "    print(\"Parsing sentences from training set\")\n",
    "    for review in train[\"review\"]:\n",
    "        sentences += KaggleWord2VecUtility.review_to_sentences(review, tokenizer)\n",
    "\n",
    "    print(\"Parsing sentences from unlabeled set\")\n",
    "    for review in unlabeled_train[\"review\"]:\n",
    "        sentences += KaggleWord2VecUtility.review_to_sentences(review, tokenizer)\n",
    "\n",
    "    # Word2Vec 参数\n",
    "    logging.basicConfig(format='%(asctime)s : %(levelname)s : %(message)s', level=logging.INFO)\n",
    "    num_features = 300\n",
    "    min_word_count = 40\n",
    "    num_workers = 4\n",
    "    context = 10\n",
    "    downsampling = 1e-3\n",
    "\n",
    "    print(\"Training Word2Vec model...\")\n",
    "    model = Word2Vec(sentences, workers=num_workers, vector_size=num_features,\n",
    "                     min_count=min_word_count, window=context, sample=downsampling, seed=1)\n",
    "\n",
    "    model_name = \"/kaggle/working/300features_40minwords_10context\"\n",
    "    model.save(model_name)\n",
    "\n",
    "    # 示例\n",
    "    print(model.wv.doesnt_match(\"man woman child kitchen\".split()))\n",
    "    print(model.wv.doesnt_match(\"france england germany berlin\".split()))\n",
    "    print(model.wv.doesnt_match(\"paris berlin london austria\".split()))\n",
    "    print(model.wv.most_similar(\"man\"))\n",
    "    print(model.wv.most_similar(\"queen\"))\n",
    "    print(model.wv.most_similar(\"awful\"))\n",
    "\n",
    "    # 创建平均向量\n",
    "    print(\"Creating average feature vecs for training reviews\")\n",
    "    trainDataVecs = getAvgFeatureVecs(getCleanReviews(train), model, num_features)\n",
    "\n",
    "    print(\"Creating average feature vecs for test reviews\")\n",
    "    testDataVecs = getAvgFeatureVecs(getCleanReviews(test), model, num_features)\n",
    "\n",
    "    # 随机森林训练与预测\n",
    "    forest = RandomForestClassifier(n_estimators=100)\n",
    "    print(\"Fitting a random forest to labeled training data...\")\n",
    "    forest = forest.fit(trainDataVecs, train[\"sentiment\"])\n",
    "\n",
    "    result = forest.predict(testDataVecs)\n",
    "\n",
    "    # 输出到 /kaggle/working/\n",
    "    output_path = \"/kaggle/working/Word2Vec_AverageVectors.csv\"\n",
    "    output = pd.DataFrame(data={\"id\": test[\"id\"], \"sentiment\": result})\n",
    "    output.to_csv(output_path, index=False, quoting=csv.QUOTE_NONE)\n",
    "    print(\"Wrote {}\".format(output_path))"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "datasetId": 8521174,
     "sourceId": 13425389,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 8521280,
     "sourceId": 13425536,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31154,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 404.362613,
   "end_time": "2025-10-19T07:44:31.304112",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-10-19T07:37:46.941499",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
